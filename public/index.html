<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Gemma3:1b Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { --maxw: 760px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #0b0b0c; color: #e6e6e6;
      display: flex; flex-direction: column;
    }
    #app { width: 100%; max-width: var(--maxw); margin: 0 auto; display: flex; flex-direction: column; height: 100%; }
    #messages {
      flex: 1; overflow-y: auto; padding: 16px 12px 8px;
      scroll-behavior: smooth;
    }
    .msg { margin: 0 0 12px 0; display: flex; }
    .role { font-weight: 600; margin-right: 8px; opacity: .7; flex: 0 0 auto; }
    .bubble {
      white-space: pre-wrap; word-wrap: break-word;
      padding: 10px 12px; border-radius: 12px; max-width: 100%;
    }
    .user   .bubble { background: #1f2430; color: #f3f3f3; }
    .assistant .bubble { background: #14171f; color: #e6e6e6; }
    #composer {
      border-top: 1px solid #22252e;
      padding: 10px 12px;
      position: sticky; bottom: 0; background: #0b0b0c;
    }
    #inputForm { display: flex; gap: 8px; }
    #prompt {
      flex: 1; border: 1px solid #2a2e3a; background: #0f121a; color: #fff;
      padding: 10px 12px; border-radius: 10px; outline: none;
    }
    #prompt:focus { border-color: #3a7afe; }
    #sendBtn {
      border: 0; background: #3a7afe; color: white; padding: 10px 14px; border-radius: 10px; cursor: pointer;
    }
    #sendBtn:disabled { opacity: .6; cursor: default; }
    /* Hide everything except chat + text bar: done */
  </style>
</head>
<body>
  <div id="app">
    <div id="messages" aria-live="polite"></div>

    <div id="composer">
      <form id="inputForm" autocomplete="off">
        <input id="prompt" type="text" placeholder="Type your message…" required />
        <button id="sendBtn" type="submit">Send</button>
      </form>
    </div>
  </div>

  <script>
    const messagesEl = document.getElementById("messages");
    const form = document.getElementById("inputForm");
    const input = document.getElementById("prompt");
    const sendBtn = document.getElementById("sendBtn");

    // Conversation state is kept ONLY in memory (not persisted).
    const convo = [];

    function addMessage(role, content) {
      const row = document.createElement("div");
      row.className = `msg ${role}`;
      const roleEl = document.createElement("div");
      roleEl.className = "role";
      roleEl.textContent = role === "user" ? "You" : "AI";
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = content; // textContent prevents HTML injection
      row.appendChild(roleEl);
      row.appendChild(bubble);
      messagesEl.appendChild(row);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return bubble; // return bubble so we can live-update assistant text
    }

    async function send(prompt) {
      // Push user message to UI and in-memory convo (no storage anywhere else)
      convo.push({ role: "user", content: prompt });
      addMessage("user", prompt);

      // Placeholder assistant bubble to stream into
      const bubble = addMessage("assistant", "");

      // Disable UI while sending
      input.disabled = true; sendBtn.disabled = true;

      try {
        const res = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: convo })
        });

        if (!res.body) {
          throw new Error("No response body");
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let assistantText = "";

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop(); // keep possible partial line

          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            try {
              const obj = JSON.parse(trimmed);
              // Ollama /api/chat streams JSONL; content can come as obj.message.content
              if (obj?.message?.content) {
                assistantText += obj.message.content;
                bubble.textContent = assistantText;
                messagesEl.scrollTop = messagesEl.scrollHeight;
              }
              // /api/generate streams use 'response'; keep compatible
              if (obj?.response) {
                assistantText += obj.response;
                bubble.textContent = assistantText;
                messagesEl.scrollTop = messagesEl.scrollHeight;
              }
              if (obj?.done) {
                // Finalize this assistant turn in memory
                convo.push({ role: "assistant", content: assistantText });
              }
            } catch {
              // Ignore non-JSON lines
            }
          }
        }

        // Try parse any trailing buffered line
        if (buffer.trim()) {
          try {
            const obj = JSON.parse(buffer.trim());
            if (obj?.message?.content) assistantText += obj.message.content;
            if (obj?.response) assistantText += obj.response;
            bubble.textContent = assistantText;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            if (obj?.done) convo.push({ role: "assistant", content: assistantText });
          } catch { /* ignore */ }
        }
      } catch (err) {
        bubble.textContent = "⚠️ Error talking to the model.";
      } finally {
        input.disabled = false; sendBtn.disabled = false;
        input.focus();
      }
    }

    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = input.value.trim();
      if (!text) return;
      input.value = "";
      send(text);
    });

    // UX nicety: Enter to send, Shift+Enter to insert newline into the single-line box (ignored)
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        form.requestSubmit();
      }
    });
  </script>
</body>
</html>
